<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: qf_port.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>qf_port.h File Reference</h1>
<p><a class="el" href="class_q_f.html" title="QF services.">QF</a> port to <a class="el" href="class_q_k.html" title="QK services.">QK</a> for a "generic" C++ compiler.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="qep__port_8h_source.html">qep_port.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qk__port_8h_source.html">qk_port.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qf_8h_source.html">qf.h</a>&quot;</code><br/>

<p><a href="qf__port_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>&nbsp;&nbsp;&nbsp;63</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of active objects in the application.  <a href="#a776d2a032974db4bf9bcfde01ace1389"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31">QF_EVENT_SIZ_SIZE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size (in bytes) of the event-size representation in the <a class="el" href="class_q_f.html" title="QF services.">QF</a>. Valid values: 1, 2, or 4; default 2.  <a href="#a1272d49c23ca5852a7a8e9603ba32d31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a54463011114f6b076e0bd62e3fa27102">QF_EQUEUE_CTR_SIZE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size (in bytes) of the ring-buffer counters used in the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation. Valid values: 1, 2, or 4; default 1.  <a href="#a54463011114f6b076e0bd62e3fa27102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4">QF_MPOOL_SIZ_SIZE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size (in bytes) of the block-size representation in the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event pool. Valid values: 1, 2, or 4; default <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1,...">QF_EVENT_SIZ_SIZE</a>.  <a href="#ac41e4f294d103c68521f9ad1f8e4e3b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#adc446a34e9e682fc5e821d203f73a6e0">QF_MPOOL_CTR_SIZE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size (in bytes) of the block-counter representation in the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event pool. Valid values: 1, 2, or 4; default 2.  <a href="#adc446a34e9e682fc5e821d203f73a6e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a80d059a0d02a2573c76f4eb5df0228ae">QF_TIMEEVT_CTR_SIZE</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size (in bytes) of the time event -counter representation in the <a class="el" href="class_q_time_evt.html" title="Time Event class.">QTimeEvt</a> class. Valid values: 1, 2, or 4; default 2.  <a href="#a80d059a0d02a2573c76f4eb5df0228ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#ab9f399fb87f8780a741e98bbf31aef99">QF_ACTIVE_BASE</a>&nbsp;&nbsp;&nbsp;<a class="el" href="class_q_hsm.html">QHsm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The macro defining the base class for <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a>.  <a href="#ab9f399fb87f8780a741e98bbf31aef99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a243406ad5c97d8a56625f0cd3bb41c67">QF_INT_KEY_TYPE</a>&nbsp;&nbsp;&nbsp;int</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the type of the interrupt lock key.  <a href="#a243406ad5c97d8a56625f0cd3bb41c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098">QF_INT_LOCK</a>(key_)&nbsp;&nbsp;&nbsp;((key_) = intLock())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the interrupt locking policy.  <a href="#aecafaa15f9f2d55cc0557f8b4c951098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186">QF_INT_UNLOCK</a>(key_)&nbsp;&nbsp;&nbsp;intUnlock(key_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the interrupt unlocking policy.  <a href="#a2f54624c77da2ce84f7666bd0695f186"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_q_f.html" title="QF services.">QF</a> port to <a class="el" href="class_q_k.html" title="QK services.">QK</a> for a "generic" C++ compiler. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of a <a class="el" href="class_q_f.html" title="QF services.">QF</a> port used for "linting" the <a class="el" href="class_q_f.html" title="QF services.">QF</a>. Ports of <a class="el" href="class_q_f.html" title="QF services.">QF</a> are located in the directory &lt;qpcpp_3&gt;/ports. </dd></dl>

<p>Definition in file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab9f399fb87f8780a741e98bbf31aef99"></a><!-- doxytag: member="qf_port.h::QF_ACTIVE_BASE" ref="ab9f399fb87f8780a741e98bbf31aef99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_ACTIVE_BASE&nbsp;&nbsp;&nbsp;<a class="el" href="class_q_hsm.html">QHsm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The macro defining the base class for <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a>. </p>
<p>By default, the <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> class is derived from <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a>. However, if the macro QF_ACTIVE_BASE is defined, <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> is derived from QF_ACTIVE_BASE.</p>
<p>Clients might choose, for example, to define QF_ACTIVE_BASE as <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a> to avoide the 1-2KB overhead of the hierarchical event processor.</p>
<p>Clients might also choose to define QF_ACTIVE_BASE as their own completely customized class that has nothing to do with <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> or <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a>. The QF_ACTIVE_BASE class must provide member functions init() and dispatch(), consistent with the signatures of <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> and <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a>. But the implementatin of these functions is completely open.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you define <a class="el" href="qf__port_8h.html#ab9f399fb87f8780a741e98bbf31aef99" title="The macro defining the base class for QActive.">QF_ACTIVE_BASE</a>, you must consistently it in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00175">175</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54463011114f6b076e0bd62e3fa27102"></a><!-- doxytag: member="qf_port.h::QF_EQUEUE_CTR_SIZE" ref="a54463011114f6b076e0bd62e3fa27102" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EQUEUE_CTR_SIZE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the ring-buffer counters used in the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation. Valid values: 1, 2, or 4; default 1. </p>
<p>This macro can be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports to configure the <a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac" title="The data type to store the ring-buffer counters based on the macro QF_EQUEUE_CTR_SIZE...">QEQueueCtr</a> type. If the macro is not defined, the default of 1 byte will be chosen in <a class="el" href="qequeue_8h.html" title="platform-independent event queue interface.">qequeue.h</a>. The valid <a class="el" href="qf__port_8h.html#a54463011114f6b076e0bd62e3fa27102" title="The size (in bytes) of the ring-buffer counters used in the native QF event queue...">QF_EQUEUE_CTR_SIZE</a> values of 1, 2, or 4, correspond to <a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac" title="The data type to store the ring-buffer counters based on the macro QF_EQUEUE_CTR_SIZE...">QEQueueCtr</a> of uint8_t, uint16_t, and uint32_t, respectively. The <a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac" title="The data type to store the ring-buffer counters based on the macro QF_EQUEUE_CTR_SIZE...">QEQueueCtr</a> data type determines the dynamic range of numerical values of ring-buffer counters inside event queues, or, in other words, the maximum number of events that the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue can manage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a54463011114f6b076e0bd62e3fa27102" title="The size (in bytes) of the ring-buffer counters used in the native QF event queue...">QF_EQUEUE_CTR_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00093">93</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1272d49c23ca5852a7a8e9603ba32d31"></a><!-- doxytag: member="qf_port.h::QF_EVENT_SIZ_SIZE" ref="a1272d49c23ca5852a7a8e9603ba32d31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EVENT_SIZ_SIZE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the event-size representation in the <a class="el" href="class_q_f.html" title="QF services.">QF</a>. Valid values: 1, 2, or 4; default 2. </p>
<p>This macro can be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports to configure the QEventSize type. If the macro is not defined, the default of 2 byte will be chosen in <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a>. The valid <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1,...">QF_EVENT_SIZ_SIZE</a> values of 1, 2, or 4, correspond to QEventSize of uint8_t, uint16_t, and uint32_t, respectively. The QEventSize data type determines the dynamic range of event-sizes in your application. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a>, <a class="el" href="class_q_f.html#a0372670610b5d72a5e985503e2ba0b6b" title="Internal QF implementation of the dynamic event allocator.">QF::new_()</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1,...">QF_EVENT_SIZ_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00074">74</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a243406ad5c97d8a56625f0cd3bb41c67"></a><!-- doxytag: member="qf_port.h::QF_INT_KEY_TYPE" ref="a243406ad5c97d8a56625f0cd3bb41c67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_INT_KEY_TYPE&nbsp;&nbsp;&nbsp;int</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the type of the interrupt lock key. </p>
<p>Defining this macro configures the "saving and restoring interrupt status" policy of locking and unlocking interrupts. Coversely, if this macro is not defined, the simple "unconditional interrupt locking and unlocking" is used. </p>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00183">183</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="aecafaa15f9f2d55cc0557f8b4c951098"></a><!-- doxytag: member="qf_port.h::QF_INT_LOCK" ref="aecafaa15f9f2d55cc0557f8b4c951098" args="(key_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_INT_LOCK</td>
          <td>(</td>
          <td class="paramtype">key_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((key_) = intLock())</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the interrupt locking policy. </p>
<p>This macro establishes a critical section (typically by locking interrupts). When the "saving and restoring interrupt status" policy is used, the macro sets the "interrupt key" to the interrupt status just before locking interrupts. When the policy of "unconditional interrupt unlocking" is used, the macro does not use the "interrupt key" parameter.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the <a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a> macro should always be used in pair with the macro <a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00195">195</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f54624c77da2ce84f7666bd0695f186"></a><!-- doxytag: member="qf_port.h::QF_INT_UNLOCK" ref="a2f54624c77da2ce84f7666bd0695f186" args="(key_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_INT_UNLOCK</td>
          <td>(</td>
          <td class="paramtype">key_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;intUnlock(key_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the interrupt unlocking policy. </p>
<p>This macro leaves a critical section (typically by unlocking interrupts). When the "saving and restoring interrupt status" policy is used, the macro restores the interrupt status from the "interrupt key" parameter. When the policy of "unconditional interrupt unlocking" is used, the macro unconditionally unlocks interrupts ignoring the "interrupt key" parameter.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the <a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a> macro should always be used in pair with the macro <a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00207">207</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a776d2a032974db4bf9bcfde01ace1389"></a><!-- doxytag: member="qf_port.h::QF_MAX_ACTIVE" ref="a776d2a032974db4bf9bcfde01ace1389" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_MAX_ACTIVE&nbsp;&nbsp;&nbsp;63</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum number of active objects in the application. </p>
<p>This macro should be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports and should be in range of 1..63, inclusive. The value of this macro determines the maximum priority level of an active object in the system. Not all priority levels must be used, but the maximum priority cannot exceed <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>.</p>
<p>If the macro is not defined, the default value is 63, which is the maximum. Defining the value below the maximum saves some memory, mostly for the subscriber-lists. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_subscr_list.html" title="Subscriber List class.">QSubscrList</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00056">56</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8cpp_source.html#l00082">QF::getQueueMargin()</a>, <a class="el" href="qvanilla_8cpp_source.html#l00085">QActive::start()</a>, <a class="el" href="qa__sub_8cpp_source.html#l00038">QActive::subscribe()</a>, <a class="el" href="qa__usub_8cpp_source.html#l00038">QActive::unsubscribe()</a>, and <a class="el" href="qa__usuba_8cpp_source.html#l00038">QActive::unsubscribeAll()</a>.</p>

</div>
</div>
<a class="anchor" id="adc446a34e9e682fc5e821d203f73a6e0"></a><!-- doxytag: member="qf_port.h::QF_MPOOL_CTR_SIZE" ref="adc446a34e9e682fc5e821d203f73a6e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_MPOOL_CTR_SIZE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the block-counter representation in the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event pool. Valid values: 1, 2, or 4; default 2. </p>
<p>This macro can be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports to configure the QMPoolCtr type. If the macro is not defined, the default of 2 bytes will be chosen in <a class="el" href="qmpool_8h.html" title="platform-independent memory pool interface.">qmpool.h</a>. The valid <a class="el" href="qf__port_8h.html#adc446a34e9e682fc5e821d203f73a6e0" title="The size (in bytes) of the block-counter representation in the native QF event pool...">QF_MPOOL_CTR_SIZE</a> values of 1, 2, or 4, correspond to QMPoolSize of uint8_t, uint16_t, and uint32_t, respectively. The QMPoolCtr data type determines the dynamic range of block-counters that the native <a class="el" href="class_q_m_pool.html" title="Native QF memory pool class.">QMPool</a> can handle, or, in other words, the maximum number of blocks that the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event pool can manage. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_m_pool.html" title="Native QF memory pool class.">QMPool</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#adc446a34e9e682fc5e821d203f73a6e0" title="The size (in bytes) of the block-counter representation in the native QF event pool...">QF_MPOOL_CTR_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00134">134</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac41e4f294d103c68521f9ad1f8e4e3b4"></a><!-- doxytag: member="qf_port.h::QF_MPOOL_SIZ_SIZE" ref="ac41e4f294d103c68521f9ad1f8e4e3b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_MPOOL_SIZ_SIZE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the block-size representation in the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event pool. Valid values: 1, 2, or 4; default <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1,...">QF_EVENT_SIZ_SIZE</a>. </p>
<p>This macro can be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports to configure the QMPoolSize type. If the macro is not defined, the default of <a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1,...">QF_EVENT_SIZ_SIZE</a> will be chosen in <a class="el" href="qmpool_8h.html" title="platform-independent memory pool interface.">qmpool.h</a>, because the memory pool is primarily used for implementing event pools.</p>
<p>The valid <a class="el" href="qf__port_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4" title="The size (in bytes) of the block-size representation in the native QF event pool...">QF_MPOOL_SIZ_SIZE</a> values of 1, 2, or 4, correspond to QMPoolSize of uint8_t, uint16_t, and uint32_t, respectively. The QMPoolSize data type determines the dynamic range of block-sizes that the native <a class="el" href="class_q_m_pool.html" title="Native QF memory pool class.">QMPool</a> can hanle. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf__port_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="The size (in bytes) of the event-size representation in the QF. Valid values: 1,...">QF_EVENT_SIZ_SIZE</a>, <a class="el" href="class_q_m_pool.html" title="Native QF memory pool class.">QMPool</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4" title="The size (in bytes) of the block-size representation in the native QF event pool...">QF_MPOOL_SIZ_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00115">115</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
<a class="anchor" id="a80d059a0d02a2573c76f4eb5df0228ae"></a><!-- doxytag: member="qf_port.h::QF_TIMEEVT_CTR_SIZE" ref="a80d059a0d02a2573c76f4eb5df0228ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_TIMEEVT_CTR_SIZE&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the time event -counter representation in the <a class="el" href="class_q_time_evt.html" title="Time Event class.">QTimeEvt</a> class. Valid values: 1, 2, or 4; default 2. </p>
<p>This macro can be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports to configure the internal tick counters of Time Events. If the macro is not defined, the default of 2 bytes will be chosen in <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a>. The valid <a class="el" href="qf__port_8h.html#a80d059a0d02a2573c76f4eb5df0228ae" title="The size (in bytes) of the time event -counter representation in the QTimeEvt class...">QF_TIMEEVT_CTR_SIZE</a> values of 1, 2, or 4, correspond to tick counters of uint8_t, uint16_t, and uint32_t, respectively. The tick counter representation determines the dynamic range of time delays that a Time Event can handle. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_time_evt.html" title="Time Event class.">QTimeEvt</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Once you choose a certain value of <a class="el" href="qf__port_8h.html#a80d059a0d02a2573c76f4eb5df0228ae" title="The size (in bytes) of the time event -counter representation in the QTimeEvt class...">QF_TIMEEVT_CTR_SIZE</a>, you must consistently use the same value in building all the QP component libraries and your own application code. The consistency is guaranteed if you define this macro only once in the <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> header file and henceforth include this header file in all builds. </dd></dl>

<p>Definition at line <a class="el" href="qf__port_8h_source.html#l00152">152</a> of file <a class="el" href="qf__port_8h_source.html">qf_port.h</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat Oct 10 22:45:27 2009 for QP/C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
