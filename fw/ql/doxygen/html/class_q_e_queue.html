<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: QEQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>QEQueue Class Reference</h1><!-- doxytag: class="QEQueue" -->
<p>Native <a class="el" href="class_q_f.html" title="QF services.">QF</a> Event Queue class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qequeue_8h_source.html">qequeue.h</a>&gt;</code></p>

<p><a href="class_q_e_queue-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_e_queue.html#acbfb6b6784dbfaa49f6d1ea42db16331">init</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *qSto[], <a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a> qLen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue.  <a href="#acbfb6b6784dbfaa49f6d1ea42db16331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_e_queue.html#aa086974d8f754734f57d982503d494ea">postFIFO</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.  <a href="#aa086974d8f754734f57d982503d494ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_e_queue.html#a5c9baad258771bdea908077ee6fc9c47">postLIFO</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.  <a href="#a5c9baad258771bdea908077ee6fc9c47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_event.html">QEvent</a> const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_e_queue.html#ae3826b4cf8c83b694d9176eae451d33c">get</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation for the Last-In-First-Out (LIFO) event posting.  <a href="#ae3826b4cf8c83b694d9176eae451d33c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_e_queue.html#aa0b18ebad584fdfa813279e5b8a2f365">getNFree</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue operation for obtaining the number of free entries still available in the queue.  <a href="#aa0b18ebad584fdfa813279e5b8a2f365"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bff20005d080fc888fcbc59b4fd16ab"></a><!-- doxytag: member="QEQueue::QF" ref="a9bff20005d080fc888fcbc59b4fd16ab" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_e_queue.html#a9bff20005d080fc888fcbc59b4fd16ab">QF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bd057458f70978840c6f18b891ea07f"></a><!-- doxytag: member="QEQueue::QActive" ref="a1bd057458f70978840c6f18b891ea07f" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_e_queue.html#a1bd057458f70978840c6f18b891ea07f">QActive</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Native <a class="el" href="class_q_f.html" title="QF services.">QF</a> Event Queue class. </p>
<p>This structure describes the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue, which can be used as the event queue for active objects, or as a simple "raw" event queue for thread-safe event passing among non-framework entities, such as ISRs, device drivers, or other third-party components.</p>
<p>The native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue is configured by defining the macro <a class="el" href="qk_8h.html#aee19c1d6e860d59dda6e539852b99dbe" title="This macro defines the type of the event queue used for the active objects.">QF_EQUEUE_TYPE</a> as <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a> in the specific <a class="el" href="class_q_f.html" title="QF services.">QF</a> port header file.</p>
<p>The <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a> structure contains only data members for managing an event queue, but does not contain the storage for the queue buffer, which must be provided externally during the queue initialization.</p>
<p>The event queue can store only event pointers, not the whole events. The internal implementation uses the standard ring-buffer plus one external location that optimizes the queue operation for the most frequent case of empty queue.</p>
<p>The <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a> structure is used with two sets of functions. One set is for the active object event queue, which needs to block the active object task when the event queue is empty and unblock it when events are posted to the queue. The interface for the native active object event queue consists of the following functions: QActive::postFIFO_(), QActive::postLIFO_(), and <a class="el" href="class_q_active.html#a29d494a0802145fdaf510ccc89c61dce" title="Get an event from the event queue of an active object.">QActive::get_()</a>. Additionally the function QEQueue_init() is used to initialize the queue.</p>
<p>The other set of functions, uses this structure as a simple "raw" event queue to pass events between entities other than active objects, such as ISRs. The "raw" event queue is not capable of blocking on the <a class="el" href="class_q_e_queue.html#ae3826b4cf8c83b694d9176eae451d33c" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out...">get()</a> operation, but is still thread-safe because it uses <a class="el" href="class_q_f.html" title="QF services.">QF</a> critical section to protect its integrity. The interface for the "raw" thread-safe queue consists of the following functions: <a class="el" href="class_q_e_queue.html#aa086974d8f754734f57d982503d494ea" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out...">QEQueue::postFIFO()</a>, <a class="el" href="class_q_e_queue.html#a5c9baad258771bdea908077ee6fc9c47" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out...">QEQueue::postLIFO()</a>, and <a class="el" href="class_q_e_queue.html#ae3826b4cf8c83b694d9176eae451d33c" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out...">QEQueue::get()</a>. Additionally the function <a class="el" href="class_q_e_queue.html#acbfb6b6784dbfaa49f6d1ea42db16331" title="Initializes the native QF event queue.">QEQueue::init()</a> is used to initialize the queue.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Most event queue operations (both the active object queues and the "raw" queues) internally use the <a class="el" href="class_q_f.html" title="QF services.">QF</a> critical section. You should be careful not to invoke those operations from other critical sections when nesting of critical sections is not supported. </dd></dl>

<p>Definition at line <a class="el" href="qequeue_8h_source.html#l00110">110</a> of file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae3826b4cf8c83b694d9176eae451d33c"></a><!-- doxytag: member="QEQueue::get" ref="ae3826b4cf8c83b694d9176eae451d33c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> const * QEQueue::get </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation for the Last-In-First-Out (LIFO) event posting. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The LIFO policy should be used only with great caution because it alters order of events in the queue. </dd>
<dd>
The function raises an assertion if the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> queue becomes full and cannot accept the event. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_e_queue.html#aa086974d8f754734f57d982503d494ea" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out...">QEQueue::postFIFO()</a>, <a class="el" href="class_q_e_queue.html#ae3826b4cf8c83b694d9176eae451d33c" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out...">QEQueue::get()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__get_8cpp_source.html#l00038">38</a> of file <a class="el" href="qeq__get_8cpp_source.html">qeq_get.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00134">QEvent::dynamic_</a>, <a class="el" href="qs_8h_source.html#l00427">QS::eqObj_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qf_8h_source.html#l00984">QS_EQC_</a>, <a class="el" href="qs_8h_source.html#l00074">QS_QF_EQUEUE_GET</a>, <a class="el" href="qs_8h_source.html#l00075">QS_QF_EQUEUE_GET_LAST</a>, <a class="el" href="qs_8h_source.html#l00165">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>, and <a class="el" href="qevent_8h_source.html#l00133">QEvent::sig</a>.</p>

<p>Referenced by <a class="el" href="qa__defer_8cpp_source.html#l00043">QActive::recall()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0b18ebad584fdfa813279e5b8a2f365"></a><!-- doxytag: member="QEQueue::getNFree" ref="aa0b18ebad584fdfa813279e5b8a2f365" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a> QEQueue::getNFree </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue operation for obtaining the number of free entries still available in the queue. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operation needs to be used with caution because the number of free entries can change unexpectedly. The main intent for using this operation is in conjunction with event deferral. In this case the queue is accessed only from a single thread (by a single AO), so the number of free entries cannot change unexpectedly.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_active.html#a2b60c62e712768b6fadfa1fd75f910e5" title="Defer an event to a given separate event queue.">QActive::defer()</a>, <a class="el" href="class_q_active.html#a0ec00766be634a8e71a380a115ecfbaa" title="Recall a deferred event from a given event queue.">QActive::recall()</a> </dd></dl>

<p>Definition at line <a class="el" href="qequeue_8h_source.html#l00205">205</a> of file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>

</div>
</div>
<a class="anchor" id="acbfb6b6784dbfaa49f6d1ea42db16331"></a><!-- doxytag: member="QEQueue::init" ref="acbfb6b6784dbfaa49f6d1ea42db16331" args="(QEvent const *qSto[], QEQueueCtr qLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEQueue::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&nbsp;</td>
          <td class="paramname"> <em>qSto</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a>&nbsp;</td>
          <td class="paramname"> <em>qLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue. </p>
<p>The parameters are as follows: <em>qSto</em>[] is the ring buffer storage, <em>qLen</em> is the length of the ring buffer in the units of event- pointers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual capacity of the queue is qLen + 1, because of the extra location fornEvt_. </dd></dl>

<p>Definition at line <a class="el" href="qeq__init_8cpp_source.html#l00035">35</a> of file <a class="el" href="qeq__init_8cpp_source.html">qeq_init.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00427">QS::eqObj_</a>, <a class="el" href="qs_8h_source.html#l00669">QS_BEGIN_</a>, <a class="el" href="qs_8h_source.html#l00680">QS_END_</a>, <a class="el" href="qf_8h_source.html#l00984">QS_EQC_</a>, and <a class="el" href="qs_8h_source.html#l00071">QS_QF_EQUEUE_INIT</a>.</p>

</div>
</div>
<a class="anchor" id="aa086974d8f754734f57d982503d494ea"></a><!-- doxytag: member="QEQueue::postFIFO" ref="aa086974d8f754734f57d982503d494ea" args="(QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEQueue::postFIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function raises an assertion if the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> queue becomes full and cannot accept the event.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_e_queue.html#a5c9baad258771bdea908077ee6fc9c47" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out...">QEQueue::postLIFO()</a>, <a class="el" href="class_q_e_queue.html#ae3826b4cf8c83b694d9176eae451d33c" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out...">QEQueue::get()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__fifo_8cpp_source.html#l00038">38</a> of file <a class="el" href="qeq__fifo_8cpp_source.html">qeq_fifo.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00427">QS::eqObj_</a>, <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qf_8h_source.html#l00984">QS_EQC_</a>, <a class="el" href="qs_8h_source.html#l00072">QS_QF_EQUEUE_POST_FIFO</a>, <a class="el" href="qs_8h_source.html#l00165">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a5c9baad258771bdea908077ee6fc9c47"></a><!-- doxytag: member="QEQueue::postLIFO" ref="a5c9baad258771bdea908077ee6fc9c47" args="(QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEQueue::postLIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function raises an assertion if the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> queue becomes full and cannot accept the event.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_e_queue.html#a5c9baad258771bdea908077ee6fc9c47" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out...">QEQueue::postLIFO()</a>, <a class="el" href="class_q_e_queue.html#ae3826b4cf8c83b694d9176eae451d33c" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out...">QEQueue::get()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__lifo_8cpp_source.html#l00038">38</a> of file <a class="el" href="qeq__lifo_8cpp_source.html">qeq_lifo.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00427">QS::eqObj_</a>, <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qf_8h_source.html#l00984">QS_EQC_</a>, <a class="el" href="qs_8h_source.html#l00073">QS_QF_EQUEUE_POST_LIFO</a>, <a class="el" href="qs_8h_source.html#l00165">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qequeue_8h_source.html">qequeue.h</a></li>
<li><a class="el" href="qeq__fifo_8cpp_source.html">qeq_fifo.cpp</a></li>
<li><a class="el" href="qeq__get_8cpp_source.html">qeq_get.cpp</a></li>
<li><a class="el" href="qeq__init_8cpp_source.html">qeq_init.cpp</a></li>
<li><a class="el" href="qeq__lifo_8cpp_source.html">qeq_lifo.cpp</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sat Oct 10 22:45:31 2009 for QP/C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
